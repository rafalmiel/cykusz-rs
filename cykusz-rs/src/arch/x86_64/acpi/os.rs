#![allow(non_snake_case)]
#![allow(unused_variables)]
/* automatically generated by rust-bindgen */

use acpica::*;
use crate::arch::x86_64::raw::mm::{PhysAddr, MappedAddr};
use crate::kernel::sync::Spin;
use alloc::boxed::Box;
use crate::arch::x86_64::raw::cpuio::Port;
use crate::kernel::timer::early_sleep;

#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsInitialize() -> ACPI_STATUS {
    AE_OK
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsTerminate() -> ACPI_STATUS {
    AE_OK
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsGetRootPointer() -> ACPI_PHYSICAL_ADDRESS {

    let mut val = 0;
    // SAFE: Called from within ACPI init context
    match unsafe { AcpiFindRootPointer(&mut val) }
    {
        AE_OK => {
            println!("Found root pointer: 0x{:x}", val);
        },
        e @ _ => {
            println!("Failed to find ACPI root pointer : {}", e);
            return 0;
        },
    }

    val as ACPI_PHYSICAL_ADDRESS
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsPredefinedOverride(
        InitVal: *const ACPI_PREDEFINED_NAMES,
        NewVal: *mut ACPI_STRING,
    ) -> ACPI_STATUS {
    unsafe {
        *NewVal = 0 as *mut _;
    }
    AE_OK
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsTableOverride(
        ExistingTable: *mut ACPI_TABLE_HEADER,
        NewTable: *mut *mut ACPI_TABLE_HEADER,
    ) -> ACPI_STATUS {
    unsafe {
        *NewTable = 0 as *mut _;
    }
    AE_OK
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsPhysicalTableOverride(
        ExistingTable: *mut ACPI_TABLE_HEADER,
        NewAddress: *mut ACPI_PHYSICAL_ADDRESS,
        NewTableLength: *mut UINT32,
    ) -> ACPI_STATUS {
    unsafe {
        *NewAddress = 0;
    }

    AE_OK
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsCreateLock(OutHandle: *mut *mut ::core::ffi::c_void) -> ACPI_STATUS {
    unsafe {
        let spin = Spin::<()>::new( () );
        *OutHandle = Box::into_raw(Box::new(spin)) as *mut core::ffi::c_void;
    }
    AE_OK
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsDeleteLock(Handle: *mut ::core::ffi::c_void) {
    unsafe {
        let b = Box::from_raw(Handle as *mut Spin::<()>);
        core::mem::drop(b)
    }
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsAcquireLock(Handle: *mut ::core::ffi::c_void) -> ACPI_SIZE {
    unsafe {
        let b = &*(Handle as *mut Spin::<()>);
        b.unguarded_obtain();
        0
    }
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsReleaseLock(Handle: *mut ::core::ffi::c_void, Flags: ACPI_SIZE) {
    unsafe {
        let b = &*(Handle as *mut Spin::<()>);
        b.unguarded_release();
    }
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsCreateSemaphore(
        MaxUnits: UINT32,
        InitialUnits: UINT32,
        OutHandle: *mut *mut ::core::ffi::c_void,
    ) -> ACPI_STATUS {
    0
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsDeleteSemaphore(Handle: *mut ::core::ffi::c_void) -> ACPI_STATUS {
    0
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsWaitSemaphore(
        Handle: *mut ::core::ffi::c_void,
        Units: UINT32,
        Timeout: UINT16,
    ) -> ACPI_STATUS {
    0
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsSignalSemaphore(Handle: *mut ::core::ffi::c_void, Units: UINT32) -> ACPI_STATUS {
    0
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsAllocate(Size: ACPI_SIZE) -> *mut ::core::ffi::c_void {
    let a = crate::kernel::mm::heap::allocate(Size as usize + core::mem::size_of::<usize>()).unwrap() as *mut usize;
    unsafe {
        *a = Size as usize;
    }

    return unsafe { a.offset(1) } as *mut ::core::ffi::c_void;
}
//#[no_mangle] #[linkage="external"]
//extern "C" fn AcpiOsAllocateZeroed(Size: ACPI_SIZE) -> *mut ::core::ffi::c_void {
//    unimplemented!()
//}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsFree(Memory: *mut ::core::ffi::c_void) {
    let a = Memory as *mut usize;
    let (ptr, size) = unsafe {
        let s = a.offset(-1).read();
        (a.offset(-1), s + core::mem::size_of::<usize>())
    };

    crate::kernel::mm::heap::deallocate(ptr as *mut u8, size);
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsMapMemory(
        Where: ACPI_PHYSICAL_ADDRESS,
        Length: ACPI_SIZE,
    ) -> *mut ::core::ffi::c_void {

    PhysAddr(Where as usize).to_mapped().0 as *mut core::ffi::c_void
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsUnmapMemory(LogicalAddress: *mut ::core::ffi::c_void, Size: ACPI_SIZE) {
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsGetPhysicalAddress(
        LogicalAddress: *mut ::core::ffi::c_void,
        PhysicalAddress: *mut ACPI_PHYSICAL_ADDRESS,
    ) -> ACPI_STATUS {

    unsafe {
        (PhysicalAddress as *mut isize).write(MappedAddr(LogicalAddress as usize).to_phys().0 as isize)
    }

    AE_OK
}
//#[no_mangle] #[linkage="external"]
//extern "C" fn AcpiOsCreateCache(
//        CacheName: *mut u8,
//        ObjectSize: UINT16,
//        MaxDepth: UINT16,
//        ReturnCache: *mut *mut ACPI_MEMORY_LIST,
//    ) -> ACPI_STATUS {
//    unimplemented!()
//}
//#[no_mangle] #[linkage="external"]
//extern "C" fn AcpiOsDeleteCache(Cache: *mut ACPI_MEMORY_LIST) -> ACPI_STATUS {
//    unimplemented!()
//}
//#[no_mangle] #[linkage="external"]
//extern "C" fn AcpiOsPurgeCache(Cache: *mut ACPI_MEMORY_LIST) -> ACPI_STATUS {
//    unimplemented!()
//}
//#[no_mangle] #[linkage="external"]
//extern "C" fn AcpiOsAcquireObject(Cache: *mut ACPI_MEMORY_LIST) -> *mut ::core::ffi::c_void {
//    unimplemented!()
//}
//#[no_mangle] #[linkage="external"]
//extern "C" fn AcpiOsReleaseObject(
//        Cache: *mut ACPI_MEMORY_LIST,
//        Object: *mut ::core::ffi::c_void,
//    ) -> ACPI_STATUS {
//    unimplemented!()
//}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsInstallInterruptHandler(
        InterruptNumber: UINT32,
        ServiceRoutine: ACPI_OSD_HANDLER,
        Context: *mut ::core::ffi::c_void,
    ) -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsRemoveInterruptHandler(
        InterruptNumber: UINT32,
        ServiceRoutine: ACPI_OSD_HANDLER,
    ) -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsGetThreadId() -> UINT64 {
    1
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsExecute(
        Type: ACPI_EXECUTE_TYPE,
        Function: ACPI_OSD_EXEC_CALLBACK,
        Context: *mut ::core::ffi::c_void,
    ) -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsWaitEventsComplete() {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsSleep(Milliseconds: UINT64) {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsStall(Microseconds: UINT32) {
    early_sleep(Microseconds as u64 / 1000)
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsReadPort(
        Address: ACPI_IO_ADDRESS,
        Value: *mut UINT32,
        Width: UINT32,
    ) -> ACPI_STATUS {
    unsafe {
        match Width {
            8 => Port::<u8>::new(Address as u16).read() as i32,
            16 => Port::<u16>::new(Address as u16).read() as i32,
            32 => Port::<u32>::new(Address as u16).read() as i32,
            _ => panic!("Unsupported port")
        }
    }
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsWritePort(Address: ACPI_IO_ADDRESS, Value: UINT32, Width: UINT32) -> ACPI_STATUS {
    unsafe {
        match Width {
            8 => Port::<u8>::new(Address as u16).write(Value as u8),
            16 => Port::<u16>::new(Address as u16).write(Value as u16),
            32 => Port::<u32>::new(Address as u16).write(Value as u32),
            _ => panic!("Unsupported port")
        }

        AE_OK
    }
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsReadMemory(
        Address: ACPI_PHYSICAL_ADDRESS,
        Value: *mut UINT64,
        Width: UINT32,
    ) -> ACPI_STATUS {
    unimplemented!();
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsWriteMemory(
        Address: ACPI_PHYSICAL_ADDRESS,
        Value: UINT64,
        Width: UINT32,
    ) -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsReadPciConfiguration(
        PciId: *mut ACPI_PCI_ID,
        Reg: UINT32,
        Value: *mut UINT64,
        Width: UINT32,
    ) -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsWritePciConfiguration(
        PciId: *mut ACPI_PCI_ID,
        Reg: UINT32,
        Value: UINT64,
        Width: UINT32,
    ) -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsReadable(Pointer: *mut ::core::ffi::c_void, Length: ACPI_SIZE) -> BOOLEAN {
    true
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsWritable(Pointer: *mut ::core::ffi::c_void, Length: ACPI_SIZE) -> BOOLEAN {
    true
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsGetTimer() -> UINT64 {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsSignal(Function: UINT32, Info: *mut ::core::ffi::c_void) -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsEnterSleep(SleepState: UINT8, RegaValue: UINT32, RegbValue: UINT32)
        -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsPrintf(Format: *const u8) {

}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsVprintf(Format: *const u8, Args: *mut __va_list_tag) {
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsRedirectOutput(Destination: *mut ::core::ffi::c_void) {
    unimplemented!()
}
//#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsGetLine(
        Buffer: *mut u8,
        BufferLength: UINT32,
        BytesRead: *mut UINT32,
    ) -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsInitializeDebugger() -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsTerminateDebugger() {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsWaitCommandReady() -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsNotifyCommandComplete() -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsTracePoint(
        Type: ACPI_TRACE_EVENT_TYPE,
        Begin: BOOLEAN,
        Aml: *mut UINT8,
        Pathname: *mut u8,
    ) {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsGetTableByName(
        Signature: *mut u8,
        Instance: UINT32,
        Table: *mut *mut ACPI_TABLE_HEADER,
        Address: *mut ACPI_PHYSICAL_ADDRESS,
    ) -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsGetTableByIndex(
        Index: UINT32,
        Table: *mut *mut ACPI_TABLE_HEADER,
        Instance: *mut UINT32,
        Address: *mut ACPI_PHYSICAL_ADDRESS,
    ) -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsGetTableByAddress(
        Address: ACPI_PHYSICAL_ADDRESS,
        Table: *mut *mut ACPI_TABLE_HEADER,
    ) -> ACPI_STATUS {
    unimplemented!()
}
#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsOpenDirectory(
        Pathname: *mut u8,
        WildcardSpec: *mut u8,
        RequestedFileType: u8,
    ) -> *mut ::core::ffi::c_void {
    unimplemented!()
}

#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsGetNextFilename(
        DirHandle: *mut ::core::ffi::c_void,
    ) -> *mut u8 {
    unimplemented!()
}

#[no_mangle] #[linkage="external"]
extern "C" fn AcpiOsCloseDirectory(DirHandle: *mut ::core::ffi::c_void) {
    unimplemented!()
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: u32,
    pub fp_offset: u32,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
